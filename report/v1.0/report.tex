\documentclass[autodetect-engine,dvi=dvipdfmx,ja=standard,
               a4j,11pt]{bxjsarticle}

\RequirePackage{geometry}
\geometry{reset,paperwidth=210truemm,paperheight=297truemm}
\geometry{hmargin=.75truein,top=20truemm,bottom=25truemm,footskip=10truemm,headheight=0mm}
%\geometry{showframe} % 本文の"枠"を確認したければ，コメントアウト
\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage{spverbatim}

\usepackage{listings,jvlisting} %日本語のコメントアウトをする場合jvlisting（もしくはjlisting）が必要

\lstset{
  basicstyle={\ttfamily\small},
  numberstyle={\ttfamily\small\llap}
  identifierstyle={\small},
  commentstyle={\smallitshape},
  keywordstyle={\small\bfseries},
  ndkeywordstyle={\small},
  stringstyle={\small\ttfamily},
  frame={htb},
  breaklines=true,
  columns=[l]{fullflexible},
  numbers=left,
  xrightmargin=0zw,
  xleftmargin=1.6zw,
  numberstyle={\scriptsize},
  stepnumber=1,
  numbersep=1zw,
  lineskip=-0.5ex
}
\renewcommand{\lstlistingname}{図}

\renewcommand{\theFancyVerbLine}{\texttt{\footnotesize{\arabic{FancyVerbLine}:}}}

% paragraph環境の■を数字に変更
\makeatletter
\renewcommand{\paragraph}{\@startsection{paragraph}{4}{\z@}%
  {1.0\Cvs \@plus.5\Cdp \@minus.2\Cdp}%
  {.1\Cvs \@plus.3\Cdp}%
  {\reset@font\sffamily\normalsize}
}
\renewcommand{\theparagraph}{%
   (\@arabic\c@paragraph)}
\makeatother
\setcounter{secnumdepth}{4}

% 数式モードで太字にするコマンド \bm{}
\newcommand{\bm}[1]{{\mbox{\boldmath $#1$}}}

% 図・表を参照するためのマクロ
\newcommand{\figref}[1]{\makebox{図~\ref{#1}}}
\newcommand{\tabref}[1]{\makebox{表~\ref{#1}}}
\newcommand{\secref}[1]{\makebox{第~\ref{#1}~章}}
\newcommand{\subsecref}[1]{\makebox{第~\ref{#1}~節}}
\newcommand{\mathref}[1]{\makebox{(\ref{#1})式}}

\title{Web SyntaxHighlighter with TypeScript \\
       v1.0系}
\date{\number\year 年\number\month 月\number\day 日}

%%======== 本文 ====================================================%%
\begin{document}
\maketitle
% 目次つきの表紙ページにする場合はコメントを外す
%{\footnotesize \tableofcontents \newpage}

%--------------------------------------------------------------------%
\section{概要}

本プロジェクトでは，TypeScriptでWebページ用のシンタックスハイライタを作成する．
また，Node.jsやその他ツールについての理解を深めることも本プロジェクトの目的である．

本プロジェクトではブログにおけるソースコードの自動スタイリングを目的とし，プログラムを作成した．
これはReactやNext.jsへの移行を想定したものであり，これを利用すれば効率的な自作ハイライティングを実装できる．

今回はシンタックスハイライトの機能実装に加え，リアルタイムにハイライトの様子を確認できるようリッチテキスト風のテキストエディタをフロントエンドとして実装していく．

本プロジェクトにおける実行環境を以下に示す．

\begin{itemize}
  \item Ubuntu 20.04.4 LTS
  \item TypeScript 5.7.2
  \item Node.js 20.11.1
  \item npm 10.4.0
  \item webpack 5.97.0
\end{itemize}
%
その他パッケージについては，使用する際に別途記述していく．

%--------------------------------------------------------------------%
\section{実行環境及びツールの概要}

\subsection{Node.jsとは}

{\bf Node.js}とは，JavaScriptの実行環境である(PythonをインストールするとPythonを開発・実行できることと同じ)．
従来Webブラウザ上でしか実行できなかったJSを，PCやサーバ上でも実行するために開発された．

サーバサイドのJS実行環境と呼ばれることが多いが，あくまでも「JSの実行環境」なので，クライアントサイドの開発にも利用できる．
(HTMLにスクリプトを読み込んでブラウザで実行せずとも，クライアントサイドの開発が可能になる．)

Node.jsの利点の1つとしては，オープンソースのパッケージを\verb|npm|でインストールして効率的な開発が可能になる点である(Pythonにおける\verb|pip|と同じ)．
これにより，\verb|<script>|タグでライブラリのロードを行わずとも，コマンド1つで利用できるようになる．

Node.jsのインストール方法は以下の通りである．

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
$ sudo apt install nodejs
\end{Verbatim}

利用の目的としては，主に以下のものが挙げられる．

\paragraph{新仕様のJS/TSでの開発}

JSやTSの最新仕様で開発した際，ブラウザがその仕様に対応していないことがある．
この問題を解決するため，旧仕様へのコンパイル(トランスコンパイル)を行う必要があるのだが，主要なトランスコンパイラである\verb|Babel|の実行環境としてNode.jsを用いることが多い．

\paragraph{Webアプリケーションの作成}

Node.jsはWebサーバの役割も果たすことができるため，RailsのようにWebアプリを開発することができる．
この場合，実行環境はNode.js，言語はJS/TS，フレームワークはExpressやNext.jsがよく用いられる．

その他にも，webpackやvite等のバンドラを利用する際や，Sassのコンパイルのために用いることもある．

\subsection{npmとは}

{\bf npm}とは，Node.jsにおけるパッケージ管理ツールである．
コマンド1つでパッケージをインストールしたり，バージョンの管理を行うことができる．

\subsubsection{主要なコマンド}

\paragraph{プロジェクトの開始({\tt package.json}の生成)}

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
$ npm init
\end{Verbatim}
%
\verb|-y|オプションを付けると，プロジェクトの初期設定情報を記した\verb|package.json|が作成される．

\paragraph{パッケージのインストール}

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
$ npm install [package name]
\end{Verbatim}
%
\verb|-g|オプションを付けるとグローバルにインストールでき，どのディレクトリからもパッケージを利用できる．

また，\verb|-D| or \verb|--save-dev|オプションを付けると，開発環境でのローカルインストールになる．
この場合，\verb|package.json|の\verb|dependencies|ではなく\verb|devDependencies|に追記される．
例えばGitからクローンした後に必要なパッケージをインストールする場合，\verb|npm i --production|とすると，そのパッケージ群はインストールされない．
そのため，開発環境依存のパッケージ(webpack等)は\verb|-D|オプションを付けるべきである．

\paragraph{パッケージのアンインストール}

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
$ npm uninstall [package name]
\end{Verbatim}
%
グローバルにインストールしたパッケージの削除には\verb|-g|オプションが必要になる．

\paragraph{npm及びパッケージのアップデート}

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
$ npm install -g npm@latest  # Update npm to latest version.
$ npm update [package name]
\end{Verbatim}
%
グローバルにインストールしたパッケージの更新には\verb|-g|オプションが必要になる．

\paragraph{パッケージの一覧表示}

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
$ npm list
\end{Verbatim}
%
グローバルにインストールしたパッケージの表示には\verb|-g|オプションが必要になる．

\subsubsection{{\tt package.json}}

Node.jsでは，\verb|package.json|を用いてプロジェクトにインストールされているすべてのパッケージを効率的に管理している．

例えばインストールしたパッケージ及びその依存パッケージは\verb|node_modules|以下に格納されるが，Gitにプッシュする際はこのディレクトリを除外することが多い．
しかし，インストールしたパッケージや依存関係を記した\verb|package.json|さえダウンロードすれば，同ディレクトリ上で\verb|npm install|を実行することですべてのパッケージを一括インストールできる．

\figref{prog:package}は本プロジェクトにおける\verb|package.json|である．

\lstinputlisting[caption={\tt package.json}, label={prog:package}]{../../package.json}

\verb|package.json|は，そのプロジェクトをnpmパッケージとして公開するという目線で読むと分かりやすい．
例えば\verb|name|はパッケージ名となる．

インストールしたパッケージは\verb|dependencies|に記述されている．
なぜ「依存関係」として記述するかというと，当プロジェクトをパッケージとして公開する場合に，一緒にインストールしてもらう必要があるものだからである．

\verb|script|はnpm-scriptと呼ばれ，スクリプト名とシェルスクリプトの組で定義する．
\verb|npm [script name]|としてコマンドを実行すると，定義したシェルスクリプトを実行できる．

\subsection{webpackとは}

{\bf webpack}とは，複数のJSファイルやCSS，画像等を1つのJSファイルにまとめるモジュールバンドラである．
モジュール分割による開発効率向上だけでなく，1つのファイルにまとめることでHTTPリクエストの数を減らすことにも繋がる．
また，JSファイルの圧縮やローカルサーバの起動等，フロントエンドにおける開発環境がwebpack一つで整う点も特徴である．

インストール方法は以下の通りである．

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
$ npm i -D webpack webpack-cli webpack-dev-server
\end{Verbatim}
%
\verb|webpack-cli|はwebpackをCUI操作するためのツールで，ver4.0以降から必要なものである．
\verb|webpack-dev-server|はローカルサーバの起動や，ソースの変更を検知(watch)しビルドの自動実行とリロードを行うツールである．

エントリポイントと呼ばれるメインのJSファイル(TSやJSXファイルも可)を基準に複数ファイルがバンドルされ，1つのJSファイルが作成される．
それをHTMLで読み込むことで，クライアントサイドでの動作を確認できる．

webpackの利用には\verb|webpack.config.js|の利用が一般的であり，詳しくは\secref{sec:dev-env}で解説する．

%--------------------------------------------------------------------%
\section{環境構築} \label{sec:dev-env}

本プロジェクトにおける環境構築の手順を示す\cite{www:8}．

\subsection{プロジェクトの開始} \label{sec:projstart}

まず，以下のコマンドでプロジェクトの初期化及び開発環境の構築に必要なパッケージのインストールを行う．

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
$ npm init -y
$ npm i -D webpack webpack-cli webpack-dev-server
$ npm i -D typescript ts-loader
$ npm i -D mini-css-extract-plugin css-loader sass sass-loader
$ npm i -D @fortawesome/fontawesome-free
$ npm i -D html-webpack-plugin
\end{Verbatim}

\subsection{スクリプトの作成}

次に，以下のnpm-scriptを用意する．

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
"dev":   "webpack serve --mode development",
"build": "webpack build --mode production"
\end{Verbatim}
%

なお，\verb|--mode|オプションの概要は以下の通りである．

\begin{itemize}
  \item {\tt development}: ソースマップが作成され，ビルド結果に付加される．
  \item {\tt production}:  ビルド結果を圧縮して生成する．
\end{itemize}

\subsection{webpackの設定}

次に，\verb|webpack.config.js|を\figref{prog:webpack}のように作成する．

\lstinputlisting[caption={\tt webpack.config.js}, label={prog:webpack}]{../../webpack.config.js}

設定のポイントをいくつかまとめる．

まず，\verb|resolve|の\verb|extensions|の指定により，JSファイルとTSファイルをモジュールとして扱うことを明示している．
例えば，\verb|module1.js|をインポートする際，\verb|import func from 'module1'|のように，拡張子を省略することができる．
これは，\verb|module1|という名前のJSファイルもしくはTSファイルをモジュールとして探すことを意味する．

また，\verb|alias|はインポート時のパスの指定を簡単化するために設定している．
これにより，絶対パスによるインポートを\verb|import foo from '@/ts/molude1'|のように記述できる．

モジュールに対するルール設定においては，\verb|test|に指定したファイルに対して\verb|loader|もしくは\verb|use|配列にしていしたモジュールを適用するよう指定している．
\verb|use|配列に指定したモジュールは配列の末尾から順に適用される点がポイントである．
例えば今回なら，\verb|sass-loader|でCSSへのコンパイルを，\verb|css-loader|でJSへのバンドルを行い，\verb|mini-css-extract-plugin|で\verb|style.css|として出力する流れとなる．

\verb|html-webpack-plugin|はHTMLをwebpackから出力するためのモジュールで，バンドルされたJSファイルやCSSファイルの読み込みを意識することなくHTMLを記述することができる．

\subsection{{\tt tsconfig.json}の設定}

まず，以下のコマンドで\verb|tsconfig.json|を作成する．

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
$ tsc --init
\end{Verbatim}

コメントを削除し，パスエイリアスの設定を施した\verb|tsconfig.json|を\figref{prog:tsconfig}に示す．

\lstinputlisting[caption={\tt tsconfig.json}, label={prog:tsconfig}]{../../tsconfig.json}


%--------------------------------------------------------------------%
\section{フロントエンドのスタイリング}

まず，シンタックスハイライトの動作確認のためにテキストエディタを作成，スタイリングする．

\subsection{FontAwesomeの設定}

\subsecref{sec:projstart}にてWebアイコンの配信サービスであるFontAwesomeをインストールしたが，エントリポイントで必要なモジュールをインポートする必要がある．
そこで，エントリポイント\verb|main.ts|の冒頭に以下の記述を追加する．

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
import '@fortawesome/fontawesome-free/js/fontawesome';
import '@fortawesome/fontawesome-free/js/solid';
import '@fortawesome/fontawesome-free/js/regular';
import '@fortawesome/fontawesome-free/css/all.css';
\end{Verbatim}

次に，CSS側から簡単に利用できるよう，以下の\verb|mixin|を作成する．

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
@mixin fontawesome($style: 'solid', $unicode) {
    @if $style == 'solid' {
        font: var(--fa-font-solid);
    } 
    @if $style == 'regular' {
        font: var(--fa-font-regular);
    } 
    @if $style == 'brands' {
        font: var(--fa-font-brands);
    }
    content: $unicode;
}
\end{Verbatim}

\subsection{背景テーマの作成}

背景は宇宙をイメージし，星が散らばるアニメーションを作成した\cite{www:10}．
これはTSによるCSSアニメーションの動的な制御によって実装した．

背景デザインに関するHTML，SCSS，TSを抜粋して\figref{prog:bg-html}--\figref{prog:bg-ts}に示す．

\begin{lstlisting}[caption={\tt index.html(背景部分抜粋)}, label={prog:bg-html}]
<body>
  <div class="bg"></div>
</body>
\end{lstlisting}


\begin{lstlisting}[caption={\tt bg.scss}, label={prog:bg-scss}]
  .bg {
    background: #000;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    perspective: 500px;
    -webkit-perspective: 500px;
    -moz-perspective: 500px;

    .stars {
        position: absolute;
        top:  50%;
        left: 50%;
        width:  1px;
        height: 1px;

        .star {
            display: block;
            position: absolute;
            top:  50%;
            left: 50%;
            width:  5px;
            height: 5px;
            border-radius: 100%;
            transform: 
              translate(-50%,-50%) rotate(var(--angle)) 
              translateY(-100px) translateZ(0)
            ;
            background: #fff;
            animation: ScatteringStars 4s var(--delay) linear infinite;
        }
    }
}
  
@keyframes ScatteringStars {
    from { 
        transform: 
            translate(-50%, -50%) rotate(var(--angle)) 
            translateY(-100px) translateZ(var(--z))
        ;
    }
    to {   
        transform: 
            translate(-50%, -50%) rotate(var(--angle)) 
            translateY(-75vw) translateZ(var(--z))
        ;
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={\tt bgAnime.ts}, label={prog:bg-ts}]
type StarConfig = {
    angle: number,
    z:     number,
    delay: string,
};

export default function bgAnime() {
    const bg = document.getElementsByClassName('bg')[0];
    const stars = document.createElement('div');
    const starsProps: StarConfig[] = [
        { angle: 0,   z: -100, delay: '-2.0s' },
        { angle: 30,  z: -200, delay: '-1.3s' },
        { angle: 60,  z: -10,  delay: '-4.2s' },
        { angle: 90,  z: -90,  delay: '-3.3s' },
        { angle: 120, z: -180, delay: '-2.1s' },
        { angle: 150, z: -300, delay: '-5.3s' },
        { angle: 180, z: -150, delay: '-6.7s' },
        { angle: 210, z: -220, delay: '-1.5s' },
        { angle: 240, z: -250, delay: '-2.4s' },
        { angle: 270, z: -30,  delay: '-3.1s' },
        { angle: 300, z: -80,  delay: '-5.0s' },
        { angle: 330, z: -120, delay: '-7.1s' },
    ];

    stars.classList.add('stars');
    bg.appendChild(stars);
    starsProps.forEach(({ angle, z, delay }) => {
        const star = document.createElement('span');
        star.classList.add('star');
        star.style.setProperty('--angle', `${angle}deg`);
        star.style.setProperty('--z',     `${z}px`);
        star.style.setProperty('--delay', delay);
        stars.appendChild(star);
    });
}

document.addEventListener('DOMContentLoaded', () => {
    bgAnime();
});
\end{lstlisting}

TS側で動的に星を表現する要素(\verb|star|)を追加しているのは，HTMLを煩雑にさせないためである．
星の数や設定値をランダムにすると，星の動きにランダムさを持たせることができる．

\subsection{エディタの作成}

次に，実際にコードを打ち込むエディタを作成する．
ヘッダ部とコンテンツ部に分けて実装し，ヘッダ部では言語の選択が行えるようにする．

エディタの枠組み部分を\figref{prog:editor-base-html}及び\figref{prog:editor-base-scss}に示す．

\begin{lstlisting}[caption={\tt index.html(エディタ枠組み抜粋)}, label={prog:editor-base-html}]
<div class="container">
    <div class="header">
        <!-- header -->
    </div>
    <div class="content">
        <!-- content -->
    </div>
</div>
\end{lstlisting}

\begin{lstlisting}[caption={\tt style.scss(エディタ枠組み抜粋)}, label={prog:editor-base-scss}]
.container {
    display: flex;
    flex-direction: column;
    z-index: 100;
    width:  80%;
    max-width: 800px;
    height: 80%;
    max-height: 500px;
    box-shadow: 0 0 15px 7px rgba(255, 255, 255, 0.5);

    .header {
        // header style
    }

    .content {
        // content style
    }
}
\end{lstlisting}

\subsubsection{ヘッダ部の作成}

エディタのヘッダ部では，ハイライト言語の表示部を用意し，これをクリックすることで言語選択のメニューが表示できるように実装していく．
メニューの表示や言語の設定等の制御はTSで行う．

\figref{prog:head-html}--\figref{prog:head-ts}にコンテンツ部のデザイン及び制御プログラムを示す．

\begin{lstlisting}[caption={{\tt index.html(ヘッダ部抜粋)}}, label={prog:head-html}]
<div class="header">
    <button id="lang-btn"></button>
    <div id="config-popup">
        <label class="item">
            <input type="radio" id="html" name="lang">
            <span>HTML</span>
        </label>
        <label class="item">
            <input type="radio" id="css" name="lang">
            <span>CSS</span>
        </label>
        <label class="item">
            <input type="radio" id="scss" name="lang">
            <span>SCSS</span>
        </label>
        <label class="item">
            <input type="radio" id="c" name="lang">
            <span>C</span>
        </label>
    </div>
</div>
\end{lstlisting}

\begin{lstlisting}[caption={{\tt style.scss(ヘッダ部抜粋)}}, label={prog:head-scss}]
@keyframes openPopup {
    0% {
        opacity: 0;
    } 100% {
        opacity: 1;
    }
}

@keyframes closePopup {
    0% {
        opacity: 1;
    } 100% {
        opacity: 0;
    }
}

.header {
    position: relative;
    height: $code_header-hgt;
    background: #000;
    box-shadow: 0px 5px 10px -5px rgba(0, 0, 0, 0.5);

    #lang-btn {
        margin-left: .5em;
        color: #fff;

        &.html::before {
            content: "< >";
            display: inline-block;
            font-weight: 900;
            font-size: 1.2em;
            color: #ec9751;
            transform:
                translateY(2px)
                scaleX(.6)
            ;
        }

        &.css::before {
            content: '#';
            font-weight: 900;
            color: #72c1ff;
            padding: 0 .5em 0 .75em;
        }

        &.scss::before {
            @include fontawesome('brands', '\f41e');
            font-size: .9em;
            padding: 0 .25em 0 0.5em;
            color: #ed5262;
        }

        &.c::before {
            content: 'C';
            font-weight: 900;
            color: #72c1ff;
            padding: 0 .5em 0 .75em;
        }
    }

    #config-popup {
        position: absolute;
        left: 1.5em;
        z-index: 600;
        opacity: 0;
        pointer-events: none;
        text-align: left;
        color: #fff;
        background: #2e3235;
        box-shadow: 0 2px 3px rgb(0,0,0,.9);
        border: 1.5px solid #bdbdbd;

        &.open {
            animation: openPopup .2s forwards;
            pointer-events: auto;
        }

        &.close {
            animation: closePopup .2s forwards;
            pointer-events: none;
        }

        
        .item {
            position: relative;
            cursor: pointer;
            display: block;
            width: 100%;
            font-size: .8em;
            padding: .25em .5em 0 1.75em;

            &:last-child {
                padding-bottom: .25em;
            }

            &:hover {
                background: rgba(255, 255, 255, .25);
            }

            &.checked {
                &::before {
                    @include fontawesome('solid', '\f00c');
                    position: absolute;
                    top:  40%;
                    left: 10%;
                }
            }
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={{\tt main.ts(ヘッダ制御部抜粋)}}, label={prog:head-ts}]
const langBtn    = <HTMLElement>document.getElementById('lang-btn');
const langList   = <HTMLCollectionOf<Element>>document.getElementsByClassName('item');
const langRadios = <NodeListOf<HTMLInputElement>>document.getElementsByName('lang');
const langConfig = <HTMLElement>document.getElementById('config-popup');

let isOpenLangConfig = false;
let currentLang = 'html';

const toggleLangConfig = () => {
    langConfig.classList.remove(isOpenLangConfig ? 'open' : 'close');
    langConfig.classList.add(isOpenLangConfig ? 'close' : 'open');
    isOpenLangConfig = !isOpenLangConfig;
}

const initRadio = () => {
    const defaultRadio = <HTMLInputElement>document.getElementById(currentLang);
    const defaultLabel = defaultRadio.parentElement;
    if (defaultRadio && defaultLabel) {
        defaultRadio.checked = true;
        defaultLabel.classList.add('checked');
    }
}

const modifyHeaderLangName = (lang: string) => {
    currentLang = lang;
    langBtn.classList.remove(...langBtn.classList);
    langBtn.classList.add(lang);
    switch (lang) {
        case 'html': langBtn.innerText = 'HTML'; break;
        case 'css':  langBtn.innerText = 'CSS';  break;
        case 'scss': langBtn.innerText = 'SCSS'; break;
        case 'c':    langBtn.innerText = 'C';    break;
    }
}

document.addEventListener('DOMContentLoaded', () => {
    initRadio();
    modifyHeaderLangName(currentLang);
});

langBtn.addEventListener('click', toggleLangConfig);

[...langList].forEach((elm, i) => {
    elm.addEventListener('click', () => {
        const radio = langRadios[i];
        [...langList].forEach(elm => {
            elm.classList.remove('checked');
        });
        if (radio.checked) {
            langList[i].classList.add('checked');
            modifyHeaderLangName(radio.id);
        }
        codeHighlight();
    });
});
\end{lstlisting}

このように，言語の初期化に関する処理をTS側に一任することで，HTMLを直接書き換えなくても良い設計になっている．
今後ハイライト対象の言語を増やす場合には，HTML，SCSS，TSにその旨の記述を追加し，スタイリングを行えば良い．


\subsubsection{コンテンツ部の作成}

シンタックスハイライトは入力トークンを適切なクラスを施した\verb|span|タグで囲むことで実現する．
しかし，\verb|textarea|の入力文字そのものにスタイルを当てることはできないという問題点がある．
そこで，{\bf テキストエリア上にコード要素をオーバレイ表示する}というアプローチを取った．
しかしこのままでは2要素を同時にスクロールできないため，TSで同時にスクロールするよう制御を行う．

\figref{prog:overlay-html}--\figref{prog:overlay-ts}にコンテンツ部のデザイン及び制御プログラムを示す．

\begin{lstlisting}[caption={{\tt index.html(コンテンツ部抜粋)}(オーバレイ)}, label={prog:overlay-html}]
<div class="content">
    <div id="line-num"></div>
    <code id="code" class="overlay"></code>
    <textarea id="text" class="text"></textarea>
</div>
\end{lstlisting}

\begin{lstlisting}[caption={{\tt style.scss(コンテンツ部抜粋)}(オーバレイ)}, label={prog:overlay-scss}]
@mixin codeContent($type: 'editor') {
    position: absolute;
    top: $code_content-padding;
    left: calc($code_line-num-width + 1em);
    font-family: $code-font;
    font-size: 1.4rem;
    line-height: 1.4;
    letter-spacing: 0;
    white-space: pre;
    overflow: auto;
    width:  calc(100% - $code_content-padding - $code_line-num-width);
    height: calc(100% - $code_content-padding * 2);

    &::-webkit-scrollbar {
        width:  10px; 
        height: 10px;
    }

    &::-webkit-scrollbar-thumb {
        background: #5e6163;
        border-radius: 7px;
        border: 2px solid transparent;
        background-clip: padding-box;
    }

    &::-webkit-scrollbar-corner {
        background: #2e3235;
        border-radius: 7px;
    }

    &::-webkit-scrollbar-track {
        background: #2e3235;
        border-radius: 7px;
        margin: 4px;
    }

    @if $type == 'line-num' {
        left: 0;
        width: $code_line-num-width;
        
        &::-webkit-scrollbar {
            display: none;
        }
    }
}

.content {
    flex: 1;
    position: relative;
    display: flex;
    background: #2e3235;

    #line-num {
        display: flex;
        flex-direction: column;
        user-select: none;
        width: 3rem;
        color: #bdbdbd;
    }

    .overlay {
        @include codeContent;
        pointer-events: none;
        color: #fff;
    }

    .text {
        @include codeContent;
        resize: none;
        background: transparent;
        color: transparent;
        caret-color: #bdbdbd;

        &::selection {
            background: rgba(55, 165, 255, 0.3);
        }
    }
}
\end{lstlisting}

\begin{lstlisting}[caption={{\tt main.ts(コンテンツ制御部抜粋)}(オーバレイ)}, label={prog:overlay-ts}]
const lineNum    = <HTMLElement>document.getElementById('line-num');
const code       = <HTMLInputElement>document.getElementById('code');
const text       = <HTMLInputElement>document.getElementById('text');

text.addEventListener("scroll", synchronizeScroll);
text.addEventListener('input', () => {
    codeHighlight();
});
text.addEventListener('keydown', (e: KeyboardEvent) => {
    if (e.key === 'Tab') {
        e.preventDefault();
        const startPos = text.selectionStart ?? 0;
        const endPos   = text.selectionEnd ?? 0;
        const newPos = startPos + 1;
        const val = text.value;
        const head = val.slice(0, startPos);
        const foot = val.slice(endPos);
        text.value = `${head}\t${foot}`;
        text.setSelectionRange(newPos, newPos);
    }
    codeHighlight();
});
\end{lstlisting}

\verb|main.ts|では，テキストエリアとオーバレイ要素の同時スクロール，及びタブ入力の実装を行っている．

本方針における課題を以下に述べる．
まず，\verb|overflow: auto;|とした場合，\verb|padding-right|が適用されない現象が起こった．
疑似要素による力技も試したが改善されなかったため，テキストエリア及びオーバレイ要素を親コンテナよりも小さく設定し，中央配置することで応急処置を図った．
また，スクロールは始まるがテキストエリアの高さも伸びてしまうという現象が起きたが，これは親要素の\verb|height|を\verb|%|指定していたのが原因であり，\verb|max-height|を指定することで解決できた．
更に，テキストエリアのスクロールが始まった状態で改行を行うと，1行分の高さが追加されず，表示が崩れる現象が起こった．
これはおそらくテキストエリアとオーバレイのスクロールが同期されていない点が問題であり，様々な解決策を試したが改善には至らなかった．

%--------------------------------------------------------------------%
\section{シンタックスハイライタの実装}

\subsection{シンタックスハイライタとは}

シンタックスハイライタとは，入力されたソースコードに適切な色付けを行うプログラムである．
本プロジェクトでは，VS Codeと同様のハイライトを施せるようシンタックスハイライタを実装する．

今回作成するのはWeb用のシンタックスハイライタであるため，何らかの言語で書かれたソースコードを入力とし，ハイライトができるよう適切な字句単位でタグで囲まれたHTMLを出力とすることになる．
例えば\figref{prog:ex-c}のCソースを入力とした場合，\figref{prog:ex-res}のHTMLを出力することを目的とする．

\begin{lstlisting}[caption={シンタックスハイライタへの入力(C言語)}, label={prog:ex-c}]
#include <stdio.h>

int main(void) {
    int a = 0;
    printf("%d\n", a);
    return 0;
}
\end{lstlisting}

\begin{lstlisting}[caption={シンタックスハイライタの出力}, label={prog:ex-res}]
<span class='hl-pp'>#include</span> <span class='hl-hf'>&lt;stdio.h&gt;</span>

<span class='hl-vt'>int</span> <span class='hl-f'>main</span><span class='hl-b-1'>(</span><span class='hl-vt'>void</span>　\\<span class='hl-b-1'>)</span> <span class='hl-b-1'>{</span>
    <span class='hl-vt'>int</span> <span class='hl-v'>a</span> = <span class='hl-n'>0</span>;
    <span class='hl-f'>printf</span><span class='hl-b-2'>(</span><span class='hl-str'>&quot;</span><span class='hl-cs'>%d</span><span class='hl-es'>\n</span><span class='hl-str'>&quot;</span>, <span class='hl-v'>a</span><span class='hl-b-2'>)</span>;
    <span class='hl-k1'>return</span> <span class='hl-n'>0</span>;
<span class='hl-b-1'>}</span>
\end{lstlisting}
%
このように，字句要素を適切に色付けできるよう\verb|<span>|タグで囲むことがシンタックスハイライタの大きな役割である．
後は，CSSでクラスごとに色を指定すればハイライトが施されることになる．

このように，何らかのソースコードをHTMLに変換するという側面を見れば，シンタックスハイライタは簡易的なコンパイラとも言える．

なお，本レポート執筆時点ではコマンドプロンプト，HTML，CSS/SCSS，及びCのハイライタの完成を目的としている．

\subsection{実装方針}

シンタックスハイライタの実装方針は次の通りである．

まず前提として，ハイライトを行うソースコードの文法は正しいものと仮定する．
細かい文法チェックを省いた簡易的なコンパイラのように構成を考えることができる．
コンパイラが「字句解析」，「構文解析」，「意味解析」，「コード生成」の4フェーズで構成されているのに倣い，
シンタックスハイライタは「字句解析」，「トークン解析」，「コード生成」の3フェーズで構成することとする．

まず「字句解析」で，与えられたソースコードを字句単位に分割し，必要に応じてトークン種別とHTMLのクラス名を付加したトークン列を生成する．
次に「トークン解析」で，字句解析で生成したトークン列をソース言語の仕様に従い属性を調整する．
最後に「コード生成」で，トークン列を順番に走査し，クラス名がある場合は字句要素を\verb|span|タグで囲いながらHTMLを生成する．
この時，元のソースコードのホワイトスペースを維持しながらHTMLを構築していく点に注意する．

\subsection{ユーザ定義型，インタフェースの定義}

シンタックスハイライタ実装に必要な型エイリアス，及びインタフェースを定義した\verb|type.ts|を\figref{prog:type}に示す．

\begin{lstlisting}[caption={インタフェースの定義({\tt type.ts})}, label={prog:type}]
export type ClassName = string | null;

interface Pattern {
    regexp:    RegExp
    className: string | null
};

export type PatternList = Record<string, Pattern>;
\end{lstlisting}

\verb|PatternList|は字句解析器に渡すオブジェクトで，正規表現(\verb|regexp|)とクラス名(\verb|className|)からなる．
この\verb|PatternList|を渡された字句解析器は，正規表現\verb|regexp|にマッチする字句要素を切り出し，クラス名を\verb|className|としてトークン列を生成する．

\subsubsection{{\tt Record}型とは}

\verb|Record|とは，\verb|key|と\verb|value|の型を指定してオブジェクト(dict，連想配列)の型を決定するutility typeである．
そのため，\verb|Record|を用いずとも同様の型構造を定義できるが，例えば以下のようになり，複雑な型定義となってしまう．

\begin{Verbatim}[numbers=left, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
interface Pattern {
    pattern:   RegExp
    className: ClassName
};

export type PatternList = { [key: string]: Pattern };
\end{Verbatim}

\subsection{クラス設計}

\figref{img:class}に本プロジェクトのクラス図を示す．

\begin{figure}[ht]
\centering
\includegraphics[scale=0.3]{class.png}
\caption{{本プロジェクトのクラス図}}
\label{img:class}
\end{figure}

\subsubsection{{\tt SyntaxHighlighter}クラス}

ソース言語によらず共通的な処理を抽象基底クラス\verb|SyntaxHighlighter|として定義する．
各ソース言語のハイライタはこの基底クラスを継承し，トークン解析を行うメソッド\verb|parseTokens()|を個別に定義する．
詳しくは\subsecref{sec:highlighterClass}以降で解説する．

\subsubsection{{\tt Token}クラス，及び{\tt TokenArray}クラス}

{\tt Token}クラス，及び{\tt TokenArray}クラスの実装を一部抜粋し，\figref{prog:token}に示す．

\begin{lstlisting}[caption={{\tt Token, TokenArray}}, label={prog:token}]
import { ClassName } from './type';

export class Token {
    lexeme:    string;
    type:      string;
    className: ClassName;
    tags:      string[];

    constructor({
        lexeme    = '',
        type      = '',
        className = null,
        tags      = [] 
    }: {
        lexeme?:    string
        type?:      string
        className?: ClassName
        tags?:      string[]
    } = {}) {
        this.lexeme    = lexeme;
        this.type      = type;
        this.className = className;
        this.tags      = tags;
    }

    setLexeme(lexeme: string) {
        this.lexeme = lexeme;
        return this;
    }

    // ...

    isLexemeEqualTo(lex: string | string[]) {
        if (Array.isArray(lex)) {
            return lex.includes(this.lexeme);
        }
        return lex === this.lexeme;
    }

    // ...
}

export class TokenArray extends Array<Token> {
    replace(pos: number, tokens: TokenArray) {
        this.splice(pos, 1, ...tokens);
        return this;
    }

    findIndexByLexeme(lex: string, startPos = 0) {
        if (startPos >= this.length) return -1;

        for (let i = Math.max(0, startPos); i < this.length; i++) {
            if (this[i].lexeme === lex) return i;
        }
        return -1;
    }

    findLastIndexByLexeme(lex: string, startPos = this.length - 1) {
        for (let i = Math.min(startPos, this.length - 1); i >= 0; i--) {
            if (this[i].lexeme === lex) return i;
        }
        return -1;
    }

    // ...
}
\end{lstlisting}

\verb|Token|は字句解析において生成するデータで，次の要素からなる．
\begin{itemize}
    \item 字句要素(\verb|lexeme|)
    \item トークン種別(\verb|type|)
    \item クラス名(\verb|className|)
    \item タグ(\verb|tag|)
\end{itemize}
%
なお，タグはトークン解析の際に付加情報として用いるプロパティである．

\verb|Token|クラス実装のポイントは，メソッドチェーンを可能とするために\verb|this|(インスタンス自身)を返している点である(28行目)．
これにより，例えば\verb|tokens.setType('var').setClassName('hl-var');|といった記述が可能となる．

\verb|TokenArray|クラスは\verb|Token|オブジェクトの配列を管理するためのものだが，これはわざわざ実装しなくとも\verb|Token[]|型で表現できる．
しかしわざわざクラスを定義している理由は，トークン検索のメソッド(\verb|findIndexByLexeme()|等)を定義するためである．
Arrayオブジェクトの\verb|indexOf()|では\verb|Token|そのものを渡さなければならないため，\verb|lexeme|のみでの検索をかけることができない．
そこで，\verb|Array|のサブクラスとしてこれを実装することで，従来の配列としてのアクセスやメソッドを保ったまま任意のメソッドを定義している．

\subsubsection{{\tt NameSpace}クラス}

{\tt NameSpace}クラスの実装を一部抜粋し，\figref{prog:namespace}に示す．

\begin{lstlisting}[caption={{\tt NameSpace}}, label={prog:namespace}]
interface NameSpaceObject {
    name: string
    type: string
};

export default class Namespace {
    private parent:   Namespace | null;
    private children: Namespace[];
    private name:     string;
    private objs:     NameSpaceObject[];

    constructor(name: string, parent: Namespace | null = null) {
        this.parent   = parent;
        this.children = [];
        this.name     = name;
        this.objs     = [];
    }

    createChildScope(scopeName: string) {
        const child = new Namespace(scopeName, this);
        this.children.push(child);
        return child;
    }

    escapeScope() {
        if (!this.parent) return this;
        return this.parent;
    }

    getGlobalScope() {
        let ns: Namespace = this;
        for (; ns.parent; ns = this.escapeScope());
        return ns;
    }

    append(objName: string, type: string) {
        if (this.hasName(objName, true)) return;
        this.objs.push({ name: objName, type });
    }

    register(str: string, type: string) {
        const objNames = str.split(' ');
        objNames.forEach(objName => this.append(objName, type));

        return this;
    }

    has(objName: string, type: string, currScopeOnly = false): boolean {
        const foundInCurrScope = this.objs.some((obj) => 
            obj.name === objName && obj.type === type
        );
    
        if (foundInCurrScope) return true;
    
        return !currScopeOnly && this.parent?.has(objName, type) || false;
    }

    getTypeByName(name: string, currScopeOnly = false): string | null {
        const foundInCurrScope = this.objs.find((obj) => obj.name === name);

        if (foundInCurrScope) return foundInCurrScope.type;

        return !currScopeOnly && this.parent ? this.parent.getTypeByName(name) : null;
    }

    // For test
    toJSON(): any {
        return {
            name: this.name,
            objs: this.objs,
            children: this.children.map((child) => child.toJSON()),
        };
    }

    private hasName(objName: string, currScopeOnly = false): boolean {
        const foundInCurrScope = this.objs.some((obj) => 
            obj.name === objName
        );
    
        if (foundInCurrScope) return true;
    
        return !currScopeOnly && this.parent?.hasName(objName) || false;
    }
}
\end{lstlisting}

\verb|NameSpace|は名前空間を管理するためのクラスで，スタックに似たデータ構造を取っている．
なお，名前空間に登録するオブジェクトはトークン解析において必要なもののみを登録すれば十分である．
(出現した変数，型エイリアス等のオブジェクトを全て登録しても良いが，厳密な構文解析は必要ないためいささか冗長である．)
\verb|push|に当たる操作は\verb|createChildScope()|であり，スコープ形成の際に呼び出す．
\verb|pop|に当たる操作は\verb|escapeScope()|であり，スコープの終わりを検知した際に呼び出す．
トークン解析において既に無効なスコープの情報も保持しておきたいため，\verb|pop|のような破壊的操作ではなく，親スコープに戻る形で実装している．

詳しい使い方については，各言語のトークン解析の解説にて触れる．

\subsection{基底クラス{\tt SyntaxHighlighter}の実装} \label{sec:highlighterClass}

\figref{prog:base}に，ハイライタ基底クラス\verb|SyntaxHighlighter|を示す．

\begin{lstlisting}[caption={ハイライタ基底クラス({\tt base.ts})}, label={prog:base}]
import { PatternList } from './type';
import { Token, TokenArray } from './token';
import { mod } from '../helper';


export default abstract class Syntaxhighlighter {
    src:    string;
    tokens: TokenArray;

    constructor(src: string, patternList: PatternList ) {
        this.src    = src;
        this.tokens = this.lexicalAnalysis(src, patternList);
    }

    abstract parseTokens(): void;

    lexicalAnalysis(src: string, patternList: PatternList, includeWhiteSpace = false) {
        const tokens = new TokenArray();
        patternList = {
            ...patternList,
            other:      { regexp: /^\S/,  className: null },
            whiteSpace: { regexp: /^\s+/, className: null }
        };

        while (src) {
            for (const type in patternList) {
                const match = src.match(patternList[type].regexp);
                if (match) {
                    const lexeme = match[0];
                    src = src.slice(lexeme.length);
                    if (type === 'whiteSpace' && !includeWhiteSpace) continue;
                    tokens.push(new Token({
                        lexeme:    lexeme,
                        type:      type,
                        className: patternList[type].className
                    }));
                    break;
                }
            }
        }
        return tokens;
    }

    generateHTML() {
        this.parseTokens();

        let highlightedSrc = '';
        let i = 0;
        this.tokens.forEach(({ lexeme, className }) => {
            const lexFrom = this.src.indexOf(lexeme, i);

            if (i < lexFrom) highlightedSrc += this.src.slice(i, lexFrom);
            highlightedSrc += className
                ? `<span class='${className}'>${this.escape(lexeme)}</span>`
                : this.escape(lexeme);
                
            i = lexFrom + lexeme.length;
        });
        if (i < this.src.length) {
            highlightedSrc += this.src.slice(i);
        }

        return highlightedSrc;
    }

    highlightBrackets() {
        const includesOpenBracket = (lex: string) => {
            return lex.includes('(') || lex.includes('{') || lex.includes('[')
                ? true
                : false
        }
        const includesCloseBracket = (lex: string) => {
            return lex.includes(')') || lex.includes('}') || lex.includes(']')
                ? true
                : false
        }

        let bracketNest = 0;
        this.tokens.forEach((token, i) => {
            if (token.hasTag('ignoreHighlightBrackets')) return;
            if (includesOpenBracket(token.lexeme)) {
                bracketNest = mod(bracketNest, 3) + 1;
                this.tokens[i].setClassName(`hl-b-${bracketNest}`);
            }
            if (includesCloseBracket(token.lexeme)) {
                this.tokens[i].setClassName(`hl-b-${bracketNest}`);
                bracketNest = bracketNest - 1 || 3;
            }
        });

        return this;
    }

    highlightEscapeSequence() {
        const patternList: PatternList = {
            escapeSequence: { regexp: /^\\(?:[0-9a-fA-F]{4}|\S)/, className: 'hl-es' },
        }

        for (let i = 0; i < this.tokens.length; i++) {
            const token = this.tokens[i];
            if (token.isTypeEqualTo('string')) this.tokens.replace(i, this.parseString(token.lexeme, patternList));
        }

        return this;
    }

    highlightConvertionSpecifier() {
        const patternList: PatternList = {
            conversionSpecifier: { regexp: /^(?:%[-+ #0]*(?:0|[1-9][0-9]*)?(?:\.(?:0|[1-9][0-9]*)?)?(?:h{1,2}|l{1,2}|[Ljzt])?[diuoxXfFgGeEpcs%])/g, className: 'hl-cs' },
        }

        for (let i = 0; i < this.tokens.length; i++) {
            const token = this.tokens[i];
            if (token.isTypeEqualTo('string')) this.tokens.replace(i, this.parseString(token.lexeme, patternList));
        }

        return this;
    }

    private parseString(lex: string, patternList: PatternList) {
        const margeTokens = (tokens: Token[]) => {
            const margedTokens = new TokenArray();
            let lexeme    = tokens[0].lexeme;
            let type      = tokens[0].type;
            let className = tokens[0].className;

            for (let i = 1; i < tokens.length; i++) {
                const token = tokens[i];
                if (type === token.type) {
                    lexeme += token.lexeme;
                } else {
                    margedTokens.push(new Token({ lexeme, type, className }));
                    lexeme    = token.lexeme;
                    type      = token.type;
                    className = token.className
                }
            }
            if (type === tokens[tokens.length - 1].type) margedTokens.push(new Token({ lexeme, type, className }));

            return margedTokens;
        }

        const tokens = this.lexicalAnalysis(lex, patternList, true).map(token => {
            if (token.type === 'other')           token.setType('string').setClassName('hl-str');
            else if (token.type !== 'whiteSpace') token.setType(token.type).setClassName(token.className);

            return token;
        });

        return margeTokens(tokens);
    }

    private escape(str: string) {
        return str.replace(/</g,  '&lt;')
                  .replace(/>/g,  '&gt;')
                  .replace(/\$/g, '&#036;')
                  .replace(/"/g,  '&quot;')
                  .replace(/'/g,  '&#39;')
                  .replace(/`/g,  '&#096;');
    }
}
\end{lstlisting}

本クラスでは，いずれのソース言語でも共通の字句解析\verb|lexicalAnalysis()|とコード生成\verb|generateHTML()|を定義している．
また，必要に応じてサブクラスから呼び出せるよう，括弧類やエスケープシーケンス，変換指定子のハイライトメソッドも定義している．

\verb|lexicalAnalysis()|はトークン列を生成するが，後のトークン解析に備えてホワイトスペースはトークンに含めるべきではない．
しかし，\verb|highlightEscapeSequence()|と\verb|highlightConvertionSpecifier()|にて利用する文字列解析メソッド\verb|parseString()|は，
トークン分割後も文字列内のホワイトスペースをそのまま保持しなくてはならない．
そこで，オプションでトークン列にホワイトスペースを含めるか否かを選択できるような設計とした．

先述した通り，トークン解析後のトークン列はホワイトスペースを含まない．
しかし，\verb|generateHTML()|は元のホワイトスペースを保ったまま\verb|HTML|を生成する必要があるため，元のソースコード\verb|src|と字句長を同期させている点がポイントである．

トークン解析\verb|parseTokens|については，ソース言語ごとに異なるため抽象メソッドとして定義している．
これにより，サブクラスに対して\verb|parseTokens()|のオーバライドを強制することができる．

\subsection{プロンプトハイライタの実装{\tt BashHighlighter}}

\figref{prog:bash}に，プロンプトハイライト用クラス\verb|BashHighlighter|を示す．

\begin{lstlisting}[caption={プロンプトハイライタ({\tt bash.ts})}, label={prog:bash}]
import Syntaxhighlighter from '../base';


export default class BashHighlighter extends Syntaxhighlighter {
    constructor(src: string) {
        super(src, {});
    }

    parseTokens() {}
}
\end{lstlisting}

プロンプトは，軸切り出しのハイライトの必要は無い．
そのため，パターンリストの登録やトークン解析の必要は無いため，最小構成のシンタックスハイライタとも言える．

今後の展望としては，任意の文字列をハイライトできるようなマークアップ記法を解釈できるように拡張することが考えられる．

\subsection{HTMLハイライタの実装{\tt HTMLHighlighter}}

\figref{prog:html}に，HTMLハイライト用クラス\verb|HTMLHighlighter|を示す．

\begin{lstlisting}[caption={HTMLハイライタ({\tt html.ts})}, label={prog:html}]
import SyntaxHighlighter from '../base';
import { Token } from '../token';
import { PatternList } from '../type';

// TODO: To highlight JS within script tags and CSS within style tags.
 
const patternList: PatternList = {
    comment:    { regexp: /^(?:<!--[\s\S]*?-->|<!--[\s\S]*)/, className: 'hl-cm'  },
    tagOpen:    { regexp: /^<[!\/]?/,                         className: 'hl-tag' },
    tagClose:   { regexp: /^\/?>/,                            className: 'hl-tag' },
    identifier: { regexp: /^[a-zA-Z_][\w:.-]*/,               className: null     },
    equal:      { regexp: /^=/,                               className: null     },
    value:      { regexp: /^(["']).*?\1/,                     className: 'hl-str' },
};

export default class HTMLHighlighter extends SyntaxHighlighter {
    constructor(src: string) {
        super(src, patternList);
    }

    parseTokens() {
        for (let i = 0; i < this.tokens.length; i++) {
            const token = this.tokens[i];
            if (token.type === 'identifier') this.parseIdentifier(i);
        }
    }

    private parseIdentifier(pos: number) {
        const prevToken = (pos > 0) ? this.tokens[pos - 1] : new Token();
        
        if (prevToken.isTypeEqualTo('tagOpen'))              this.tokens[pos].setType('tagName').setClassName('hl-tn');
        if (prevToken.isTypeEqualTo(['tagName', 'value']))   this.tokens[pos].setType('attr').setClassName('hl-attr');
    }
}
\end{lstlisting}

HTMLのハイライトは非常に単純で，トークンの大半が字句解析終了時点においてクラス名が確定する．

しかし，\verb|identifier|トークンは「タグ名」か「属性名」か否かが字句解析では判別できない．
そこで，この分類をトークン解析にてトークンの並び順を元に行っている．

今後の展望としては，\verb|<script>|タグで囲まれた範囲にJS用のハイライトを施すといった拡張が考えられる．

\subsection{CSS/SCSSハイライタの実装{\tt SCSSHighlighter}}

CSS/SCSSのトークン解析を行うに当たっては，\verb|identifier|の属性決定が重大な課題であった．
これは，プロパティやセレクタ，値，属性，属性値と候補が多い上に，単なるトークン走査では確定し切れないからである．
(例えば\verb|':'|は，セレクタにもプロパティと値の区切り文字にも用いられる．)

CSS/SCSSのトークン解析の実装は複雑で，改善を繰り返していくうちに，2つの方針が定まった．
以下，各方針について説明していく．

\subsubsection{方針1: 段階的に字句を分割}

一つ目の実装方針は，字句要素を段階的に分割する方法である．
この方針で実装したCSSハイライタを\figref{prog:scss1}に示す．

\begin{lstlisting}[caption={CSS/SCSSハイライタ({\tt scss.ts})(1)}, label={prog:scss1}]
import SyntaxHighlighter from '../base';
import { Token, TokenArray } from '../token';
import { PatternList } from '../type';


const patternList: PatternList = {
    comment:   { regexp: /^(?:\/\/.*|\/\*[\s\S]*?\*\/|\/\*[\s\S]*)/,     className: 'hl-cm'  },
    propVal:   { regexp: /^\S+\s*:\s*[^{](?:[^{]|\s)*?;/,                className: null     },  
    keyword1:  { regexp: /^(?:as)(?!\w)/,                                className: 'hl-k1'  },
    keyword2:  { regexp: /^(?:\*)(?!\w)/,                                className: 'hl-k2'  },
    string:    { regexp: /^(["']).*?\1/,                                 className: 'hl-str' },
    atRules:   { regexp: /^@(?:use|else)(?!\w)/,                         className: 'hl-at'  },
    include:   { regexp: /^@include\s+\S[\s\S]*?;/,                      className: null     },
    extend:    { regexp: /^@extend\s+\S+\s*?;/,                          className: null     },
    if:        { regexp: /^@(?:else\s+)?if\s+\S[\s\S]*?{/,               className: null     },
    userDef:   { regexp: /^@(?:keyframes|mixin|function)\s+\S[\s\S]*?{/, className: null     },
    selectors: { regexp: /^(?:[&.#\[>+~\w][\s\S]*?|:root\s*){/,          className: null     },
};

export default class SCSSHighlight extends SyntaxHighlighter {
    constructor(src: string) {
        super(src, patternList);
    }

    parseTokens() {
        const newTokens = new TokenArray();
        
        // TODO: for, each, etc...
        this.tokens.forEach(token => {
            switch (token.type) {
                case 'comment':   newTokens.push(new Token({...token, tags: ['ignoreHighlightBrackets']})); break;
                case 'propVal':   newTokens.push(...this.parsePropVal(token.lexeme));                       break;
                case 'include':   newTokens.push(...this.parseInclude(token.lexeme));                       break;
                case 'extend':    newTokens.push(...this.parseExtend(token.lexeme));                        break;
                case 'if':        newTokens.push(...this.parseIf(token.lexeme));                            break;
                case 'userDef':   newTokens.push(...this.parseUserDef(token.lexeme));                       break;
                case 'selectors': newTokens.push(...this.parseSelectors(token.lexeme));                     break;
                default:          newTokens.push(token);
            }
        });

        this.tokens = newTokens;
        this.highlightBrackets()
            .highlightEscapeSequence();
    }

    private parsePropVal(lex: string) {
        const tokens = new TokenArray();

        const lexemes = lex.splitWithRest(':', 1); // split with first ':'. (e.g.) 'a:b:c' => ['a', 'b:c']
        const prop    = lexemes[0].trim();
        const values  = lexemes[1].slice(0, -1).trim();

        tokens.push(new Token({ lexeme: prop, type: 'property', className: 'hl-prop' }));
        tokens.push(new Token({ lexeme: ':',  type: 'other',    className: null }));
        tokens.push(...this.parseValues(values));
        tokens.push(new Token({ lexeme: ';',  type: 'other',    className: null }));
        
        return tokens;
    }

    private parseValues(lex: string) {
        const patternList: PatternList = {
            number:     { regexp: /^(?:-?\.?[0-9]+(?:px|rem|em|%|vw|vh|vmin|vmax|s)?)/,    className: 'hl-n'   },
            color:      { regexp: /^#[0-9a-fA-F]*/,                                        className: 'hl-val' },
            string:     { regexp: /^(["']).*?\1/,                                          className: 'hl-str' },
            important:  { regexp: /^!important/,                                           className: 'hl-k2'  },
            operator:   { regexp: /^(?:and|or|not)/,                                       className: null     },  // For expression
            boolean:    { regexp: /^true|false/,                                           className: null     },  // For expression
            funcCall:   { regexp: /^[A-Za-z_$][\w$-]*\s*\(\s*(?:[^()]*|\([^()]*\))*\s*\)/, className: null     },
            identifier: { regexp: /^(?:--)?[A-Za-z_$][\w$-]*/,                             className: null     },
        }
    
        const tokens = this.lexicalAnalysis(lex, patternList);
        const newTokens = new TokenArray();
    
        tokens.forEach(token => {
            switch (token.type) {
                case 'funcCall':   newTokens.push(...this.parseFuncHead(token.lexeme)); break;
                case 'identifier': newTokens.push(this.parseIdentifier(token.lexeme));  break;
                default:           newTokens.push(token);
            }
        });
        
        return newTokens;
    }

    private parseIdentifier(lex: string){
        return lex.startsWith('$') || lex.startsWith('--')
            ? new Token({ lexeme: lex, type: 'variable', className: 'hl-v' })
            : new Token({ lexeme: lex, type: 'value',    className: 'hl-val' })
    }

    private parseFuncHead(lex: string) {
        const patternList: PatternList = {
            identifier: { regexp: /^[A-Za-z_$-][\w$-]*/, className: null },
            argList:    { regexp: /^\([\s\S]*\)/,        className: null },
        }
        const tokens = this.lexicalAnalysis(lex, patternList);
        const newTokens = new TokenArray();

        const funcNameToken = tokens.filter(({ type }) => type === 'identifier');
        const argListToken  = tokens.filter(({ type }) => type === 'argList');

        if (!argListToken.length) return [new Token({ lexeme: lex, type: 'function', className: 'hl-f' })];

        const funcName = funcNameToken[0].lexeme;
        const args     = argListToken[0].lexeme.slice(1, -1).trim();

        newTokens.push(new Token({ lexeme: funcName, type: 'function', className: 'hl-f' }));
        newTokens.push(new Token({ lexeme: '(',      type: 'other',    className: null }));
        newTokens.push(...this.parseArgs(args));
        newTokens.push(new Token({ lexeme: ')',      type: 'other',    className: null }));  

        return newTokens;
    }

    private parseArgs(lex: string) {
        const tokens = new TokenArray();

        const args = lex.split(',');
        
        args.forEach(arg => {
            arg = arg.trim();
            if (arg.includes(':')) tokens.push(...this.parseOptArg(arg)); 
            else                   tokens.push(...this.parseValues(arg)); // normal argument => treat as 'values' and parse it.
            tokens.push(new Token({ lexeme: ',', type: 'other', className: null }));
        });
        tokens.pop();

        return tokens;
    }

    private parseOptArg(lex: string) {
        const tokens = new TokenArray();

        const lexemes  = lex.split(':');
        const variable = lexemes[0].trim();
        const value    = lexemes[1];

        tokens.push(new Token({ lexeme: variable, type: 'variable', className: 'hl-prop' }));
        tokens.push(new Token({ lexeme: ':',      type: 'other',    className: null }));
        tokens.push(...this.parseValues(value));
        
        return tokens;
    }

    private parseInclude(lex: string) {
        const tokens = new TokenArray();

        const mixin  = lex.split('@include')[1].trim().slice(0, -1).trim();
    
        tokens.push(new Token({ lexeme: '@include',  type: 'atRules',  className: 'hl-at' }));
        tokens.push(...this.parseFuncHead(mixin));
        tokens.push(new Token({ lexeme: ';',         type: 'other',    className: null }));

        return tokens;
    }

    private parseExtend(lex: string) {
        const tokens = new TokenArray();

        const lexemes  = lex.split(/\s+/);
        const keyword  = lexemes[0];
        const selector = lexemes[1].split(';')[0].trim();
        
        tokens.push(new Token({ lexeme: keyword,  type: 'atRules',  className: 'hl-at' }));
        tokens.push(new Token({ lexeme: selector, type: 'selector', className: 'hl-sel' }));
        tokens.push(new Token({ lexeme: ';',      type: 'other',    className: null }));

        return tokens;
    }

    private parseIf(lex: string) {
        const tokens = new TokenArray();

        const atRules = lex.startsWith('@if') ? ['@if'] : ['@else', 'if'];
        const expr    = lex.split(/if/)[1].slice(0, -1).trim();
        
        atRules.forEach(lex => {
            tokens.push(new Token({ lexeme: lex, type: 'atRules', className: 'hl-at' }));
        });
        tokens.push(...this.parseValues(expr));
        tokens.push(new Token({ lexeme: '{', type: 'other', className: null }));  

        return tokens;        
    }

    private parseUserDef(lex: string) {
        const tokens = new TokenArray();

        const lexemes  = lex.splitWithRest(/\s+/, 1);
        const atRule   = lexemes[0];
        const funcHead = lexemes[1].slice(0, -1).trim();

        tokens.push(new Token({ lexeme: atRule, type: 'atRules', className: 'hl-at' }));
        tokens.push(...this.parseFuncHead(funcHead));
        tokens.push(new Token({ lexeme: '{',    type: 'other',   className: null }));

        return tokens;
    }

    private parseSelectors(lex: string) {
        const patternList: PatternList = {
            symbol:   { regexp: /^(?:&|\*)/,               className: 'hl-k2'  },
            selector: { regexp: /^[.#]?[A-Za-z_:][\w:-]*/, className: 'hl-sel' },
            attr:     { regexp: /^\[.*?\]/,       className: null     },
        };
        const tokens = this.lexicalAnalysis(lex, patternList);
        const newTokens = new TokenArray();

        tokens.forEach(token => {
            if (token.type === 'attr') newTokens.push(...this.parseAttr(token.lexeme));
            else                       newTokens.push(token);
        });

        return newTokens;
    }

    private parseAttr(lex: string) {
        const tokens = new TokenArray();

        const lexemes = lex.slice(1, -1).split('=');
        const attr    = lexemes[0].trim();
        const value   = lexemes.length > 1 ? lexemes[1].trim() : null;

        tokens.push(new Token({ lexeme: '[',  type: 'other', className: null }));
        tokens.push(new Token({ lexeme: attr, type: 'attr',  className: 'hl-attr' }));
        if (value) {
            tokens.push(new Token({ lexeme: '=',   type: 'other', className: null }));
            tokens.push(new Token({ lexeme: value, type: 'value', className: 'hl-val' }));
        }
        tokens.push(new Token({ lexeme: ']', type: 'other', className: null }));

        return tokens;
    }
}
\end{lstlisting}

本方針の利点は，トークン解析を簡単化できる点である．
一つのまとまった構文を字句として切り出し，そこから徐々に最小単位になるまで字句解析を繰り返すことで，トークン列を確定していく．

ただし，考えられる欠点としては次の三つがある．
一つ目は，字句解析を何度も行うため計算量やメモリ効率においてパフォーマンスが悪い点である．
二つ目は，コード全体の見通しが悪く，保守性に優れない点．
三つめは，構文ごとに解析関数を作成しなければならず，言語仕様の変更に弱い点である．
実際，本方針では未だに\verb|for|文や\verb|each|文に対応していない．

\subsubsection{組み込みオブジェクトの拡張}

JSの\verb|split|メソッドはPython等とは異なり，最大分割数を超えた文字列は破棄されてしまう．
例えば以下のような挙動となる．

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
'color: getColor($var: red);'.split(':', 2);  // ['color', ' getColor($var']
// I want to get an array ['color', 'getColor($var: red);'].
\end{Verbatim}

そこで，Pythonと同等の\verb|split|メソッドの挙動を得られるよう，\verb|String|クラスに拡張メソッドを定義することを考える．

\paragraph{{\tt interface}の拡張}

組み込みオブジェクトである\verb|String|に，拡張メソッド\verb|splitWithRest()|を定義したい．
そこで，以下のようにインタフェースを拡張する．

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
interface String {
    splitWithRest(separator: string | RegExp, limit?: number): string[];
}
\end{Verbatim}
%
これにより\verb|String|オブジェクトに\verb|splitWithRest()|を定義することができる．

\paragraph{メソッド本体の実装}

まず前提として，JS(TS)はプロトタイプベースのオブジェクト指向言語である．
JSでは各オブジェクトは内部に\verb|prototype|プロパティを保持し，そこにメソッド本体の定義等が行われている．

そのため，\verb|interface|を拡張した後は以下のようにメソッド本体の定義が可能である．

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
String.prototype.splitWithRest = function (separator: string | RegExp, limit?: number) {
    if (limit === undefined) return this.split(separator);
    if (limit < 0)           return this.split(separator);
    if (limit === 0)         return [String(this)];

    let   rest = String(this);
    const ary = [];

    const parts = String(this).split(separator);

    while (limit--) {
        const part = parts.shift();
        if (part === undefined) break;
        ary.push(part);
        rest = rest.slice(part.length);
        const match = rest.match(separator);
        if (match) rest = rest.slice(match[0].length);
    }
    if (parts.length > 0) ary.push(rest);

    return ary;
}
\end{Verbatim}
%
このように，\verb|prototype|は自由に書き換え可能なのだが，その自由度ゆえに名前空間の衝突等が起こり得る(これを{\bf プロトタイプ汚染}という)．
また，この性質はあらゆるオブジェクトを改変できることを意味するため，XSS等の攻撃にも通ずる重大な脆弱性である．

そこでプロトタイプ汚染を抑制するため，\verb|Object.defineProperties()|を利用する．
適切な属性を付加しつつ\verb|prototype|を変更することで，安全性を高めることが目的である．

\begin{Verbatim}[numbers=none, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
Object.defineProperties(String.prototype, {
    splitWithRest: {
        configurable: true,
        enumerable: false,
        writable: true,
        value: function (separator: string | RegExp, limit?: number) {
            if (limit === undefined) return this.split(separator);
            if (limit < 0)           return this.split(separator);
            if (limit === 0)         return [String(this)];

            let   rest = String(this);
            const ary = [];

            const parts = String(this).split(separator);

            while (limit--) {
                const part = parts.shift();
                if (part === undefined) break;
                ary.push(part);
                rest = rest.slice(part.length);
                const match = rest.match(separator);
                if (match) rest = rest.slice(match[0].length);
            }
            if (parts.length > 0) ary.push(rest);

            return ary;
        },
    }
});
\end{Verbatim}
%
※ここで，メソッド定義の際にアロー関数ではなく\verb|function|を使っているのは，\verb|this|の値の変更を防ぐためである．

これはグローバルな宣言ではないため，このメソッドの利用には定義ファイルをインポートする必要があることを付記しておく．


\subsubsection{方針2:トークンの並びを元に解析}

二つ目の実装方針は，HTMLハイライタと同様にトークンの並び順を元に解析する方法である．
この方針で実装したCSSハイライタを\figref{prog:scss2}に示す．

\begin{lstlisting}[caption={CSS/SCSSハイライタ({\tt scss.ts})(2)}, label={prog:scss2}]
import SyntaxHighlighter from '../base';
import { Token } from '../token';
import { PatternList } from '../type';


const patternList: PatternList = {
    comment:    { regexp: /^(?:\/\/.*|\/\*[\s\S]*?\*\/|\/\*[\s\S]*)/,                        className: 'hl-cm'  },
    keyword1:   { regexp: /^(?:as)(?!\w)/,                                                   className: 'hl-k1'  },
    keyword2:   { regexp: /^(?:&|!important|true|false)/,                                    className: 'hl-k2'  },
    if:         { regexp: /^@(?:else[ ]+)?if/,                                               className: 'hl-at'  },
    atRules:    { regexp: /^@(?:use|keyframes|function|mixin|include|extend|else|for|each)/, className: 'hl-at'  },
    logicalOp:  { regexp: /^(?:and|or|not)/,                                                 className: null     },
    color:      { regexp: /^#(?:[0-9a-fA-F]{6}|[0-9a-fA-F]{3})/,                             className: 'hl-val' },
    variable:   { regexp: /^(?:--|\$)[A-Za-z_$][\w$-]*/,                                     className: 'hl-v'   },
    identifier: { regexp: /^[.#]?-?[A-Za-z_][\w-]*/,                                         className: null     },
    number:     { regexp: /^(?:-?\.?[0-9]+(?:px|rem|em|%|vw|vh|vmin|vmax|s)?)/,              className: 'hl-n'   },
    string:     { regexp: /^(["']).*?\1/,                                                    className: 'hl-str' },
    equivalent: { regexp: /^==/,                                                             className: null     },
    asterisk:   { regexp: /^\*/,                                                             className: null     },
    coron:      { regexp: /^:/,                                                              className: null     },
    semic:      { regexp: /^;/,                                                              className: null     },
    connector:  { regexp: /^[,>+~]/,                                                         className: null     },
};

export default class SCSSHighlighter extends SyntaxHighlighter {
    constructor(src: string) {
        super(src, patternList);
    }

    parseTokens() {
        for (let i = 0; i < this.tokens.length; i++) {
            const token = this.tokens[i];
            switch (token.type) {
                case 'comment':      this.tokens[i].addTag('ignoreHighlightBrackets'); break;
                case 'if':           this.parseIf(i);                                  break;
                case 'color':        this.parseColor(i);                               break;
                case 'identifier':   this.parseIdentifier(i);                          break;
                case 'coron':        this.parseCoron(i);                               break;
            }
        }
        for (let i = 0; i < this.tokens.length; i++) {
            const token = this.tokens[i];
            switch (token.type) {
                case 'identifier': this.tokens[i].setType('value').setClassName('hl-val'); break;
                case 'asterisk':   this.parseAsterisk(i);                                  break;
                case 'coron':      this.parseCoron(i);                                     break;
            }
        }

        this.highlightBrackets()
            .highlightEscapeSequence();
    }

    private parseIf(pos: number) {
        const from = pos + 1;
        const to   = this.tokens.findIndexByLexeme('{', pos) - 1;
        for (let i = from; i <= to; i++) {
            const token = this.tokens[i];
            if      (token.isTypeEqualTo('identifier')) this.tokens[i].setType('value').setClassName('hl-val');
            else if (token.isTypeEqualTo('color'))      this.tokens[i].addTag('ignoreParseColor');
        }
    }

    private parseColor(pos: number) {
        if (!this.tokens[pos].hasTag('ignoreParseColor') && this.isSelector(pos)) this.tokens[pos].setType('selector').setClassName('hl-sel');
    }

    private parseIdentifier(pos: number) {
        const prevToken = (pos > 0)                      ? this.tokens[pos - 1] : new Token();
        const nextToken = (pos + 1 < this.tokens.length) ? this.tokens[pos + 1] : new Token();

        if (prevToken.isLexemeEqualTo('@extend')) {
            this.tokens[pos].setType('selector').setClassName('hl-sel');
        } else if (prevToken.isLexemeEqualTo(['@keyframes', '@function', '@mixin', '@include'])) {
            this.tokens[pos].setType('function').setClassName('hl-f');
        } else if (nextToken.isLexemeEqualTo('(') && !this.isSelector(pos)) {
            this.tokens[pos].setType('function').setClassName('hl-f');
        } else if (nextToken.isLexemeEqualTo('=')) {
            this.tokens[pos].setType('attr').setClassName('hl-attr');
        } else if (prevToken.isLexemeEqualTo('=')) {
            this.tokens[pos].setType('value').setClassName('hl-val');
        } else if (this.isProperty(pos, nextToken)) {
            this.tokens[pos].setType('property').setClassName('hl-prop');
        } else if (this.isSelector(pos)) {
            this.tokens[pos].setType('selector').setClassName('hl-sel');
        }
    }

    private parseAsterisk(pos: number) {
        const prevToken = (pos > 0)                      ? this.tokens[pos - 1] : new Token();
        const nextToken = (pos + 1 < this.tokens.length) ? this.tokens[pos + 1] : new Token();
    
        if ((prevToken.isLexemeEqualTo(')') || prevToken.isTypeEqualTo(['variable', 'number'])) &&
            (nextToken.isTypeEqualTo(['variable', 'function', 'number']))) {
            return;
        } else {
            this.tokens[pos].setType('keyword2').setClassName('hl-k2');
        }
    }

    private parseCoron(pos: number) {
        const nextToken = (pos + 1 < this.tokens.length) ? this.tokens[pos + 1] : new Token();
        if (nextToken.isTypeEqualTo('coron'))    this.parseCoron(pos + 1);
        if (nextToken.isTypeEqualTo('selector')) this.tokens[pos].setType('selector').setClassName('hl-sel');
    }

    private isProperty(pos: number, nextToken: Token) {
        if (!nextToken.isTypeEqualTo('coron')) return false;

        const semicPos = this.tokens.findIndexByType('semic', pos);
        const lcurPos  = this.tokens.findIndexByLexeme('{', pos);
        
        return semicPos > 0 && semicPos < lcurPos || lcurPos < 0;
    }

    private isSelector(pos: number) {
        const lcurPos  = this.tokens.findIndexByLexeme('{', pos);
        const semicPos = this.tokens.findIndexByType('semic', pos);
        return lcurPos > 0 && lcurPos < semicPos || semicPos < 0;
    }
}
\end{lstlisting}

本方針の利点は，あらかじめ最小単位で字句解析が終了するため，本来の実装方針にマッチしたシンタックスハイライタの構成を取れる点である．
トークン解析において字句解析を行うことがないため，コード全体の見通しも方針1と比べて良い．

ただし，先述した通りトークン解析は複雑であるため，一回のトークン列走査では全てのトークンを確定させることができない．
そこで，トークン列の走査を段階的に二回行うことで，最終的に解析を完了させている．

\subsection{Cハイライタの実装{\tt CHighlighter}}

Cハイライタでは，識別子\verb|identifier|を「変数」，「関数」，「マクロ定数」，「構造体，共用体，\verb|typedef|名」，「\verb|enum|メンバ」の5つに分類する必要がある．
そこでまず，Cにおける変数スコープ，及び名前空間について整理する．

\begin{itemize}
    \item 変数のスコープはブロック単位であり，\verb|typedef|名にもこれは適用される．
    \item {bf 同一スコープにおいては}\verb|typedef|名を識別子(変数名，関数名)として使用してはならない．
\end{itemize}
%
以下は検証用プログラムである．

\begin{Verbatim}[numbers=left, xleftmargin=8mm, numbersep=6pt, fontsize=\small, baselinestretch=0.8]
#include <stdio.h>

typedef char alias;

// void alias(void) {}  // Error

struct alias {
    int a;
};

int main(void) {
    int alias[100];
    printf("%ld\n", sizeof(alias));  // Output: 400

    typedef char type;

    type a = 'A';
    printf("%c\n", a);  // Output: A

    // int type;  // Error

    {
        typedef int type;   // Shadowing the outer 'type'
        type b = 42;
        printf("%d\n", b);  // Output: 42
    }

    // printf("%d\n", b);  // Error

    type c = 'C';
    printf("%c\n", c);  // Output: C

    return 0;
}
\end{Verbatim}

\figref{prog:c}に，Cハイライト用クラス\verb|CHighlighter|を示す．

\begin{lstlisting}[caption={Cハイライタ({\tt c.ts})}, label={prog:c}]
import Syntaxhighlighter from '../base';
import Namespace from '../namespase';
import { Token } from '../token';
import { PatternList } from '../type';


const macroConstant = "EOF NULL sizeof stderr stdin stdout";
const alias = "FILE size_t";

const patternList: PatternList = {
    comment:       { regexp: /^(?:\/\/.*|\/\*[\s\S]*?\*\/|\/\*[\s\S]*)/,       className: 'hl-cm'  },
    for:           { regexp: /^for(?!\w)/,                                     className: 'hl-k1'  },
    keyword:       { regexp: /^(?:return|while|if|else|break|continue)(?!\w)/, className: 'hl-k1'  },
    define:        { regexp: /^#define/,                                       className: 'hl-pp'  },
    preprocessor:  { regexp: /^#(?:include|if|endif|ifdef|ifndef)/,            className: 'hl-pp'  },
    headerFile:    { regexp: /^(?:<.+\.h>)/,                                   className: 'hl-hf'  },
    typedef:       { regexp: /^typedef(?!\w)/,                                 className: 'hl-k2'  },
    struct:        { regexp: /^(?:struct|union)(?!\w)/,                        className: 'hl-k2'  },
    enum:          { regexp: /^enum(?!\w)/,                                    className: 'hl-k2'  },
    variableType:  { regexp: /^(?:int|float|double|char|void)(?!\w)/,          className: 'hl-vt'  },
    identifier:    { regexp: /^[A-Za-z_]\w*/,                                  className: null     },
    string:        { regexp: /^(["']).*?\1/,                                   className: 'hl-str' },
    number:        { regexp: /^(?:0x[0-9a-fA-F]+|[0-9]+(?:\.[0-9]+)?)\b/,      className: 'hl-n'   },
    memberRef:     { regexp: /^(?:\.|->)/,                                     className: null     },
    lcur:          { regexp: /^{/,                                             className: null     },
    rcur:          { regexp: /^}/,                                             className: null     },
    comma:         { regexp: /^,/,                                             className: null     },
    semic:         { regexp: /^;/,                                             className: null     },
};

export default class CHighlighter extends Syntaxhighlighter {
    nsStack:         Namespace;
    isStackedByFunc: boolean;

    constructor(src: string) {
        super(src, patternList);
        this.nsStack         = new Namespace();
        this.isStackedByFunc = false;

        this.nsStack.register(macroConstant, 'macroConstant')
                    .register(alias, 'alias');
    }

    parseTokens() {
        for (let i = 0; i < this.tokens.length; i++) {
            const token = this.tokens[i];
            switch (token.type) {
                case 'comment':      this.tokens[i].addTag('ignoreHighlightBrackets'); break;
                case 'define':       this.parseDefine(i);                              break;
                case 'typedef':      this.parseTypedef(i);                             break;
                case 'struct':       this.parseStruct(i);                              break;
                case 'enum':         this.parseEnum(i);                                break;
                case 'variableType': this.parseDeclaration(i);                         break;
                case 'identifier':   this.parseIdentifier(i);                          break;
                case 'lcur':         this.stackNamespace(i); break;
                case 'rcur':         this.popNamespace(i);       break;
            }
        }
        
        this.tokens.forEach(({ lexeme, type }, i) => {
            if (type === 'identifier') {
                if (this.nsStack.has(lexeme, 'function')) {
                    this.tokens[i].setType('function').setClassName('hl-f');
                } else {
                    this.tokens[i].setType('variable').setClassName('hl-v');
                }
            }
        });

        this.highlightBrackets()
            .highlightEscapeSequence()
            .highlightConvertionSpecifier();
    }

    private parseDefine(kwPos: number) {
        if (this.tokens.length <= kwPos + 1) return;
        
        const ident = this.tokens[kwPos + 1];
        this.tokens[kwPos + 1].setType('macroConstant').setClassName('hl-mc');
        this.nsStack.append(ident.lexeme, 'macroConstant');
    }

    private parseTypedef(kwPos: number) {
        if (this.tokens.length <= kwPos + 1) return;
        
        const nextToken = this.tokens[kwPos + 1];
        const identPos = (nextToken.isTypeEqualTo(['struct', 'enum'])) 
            ? this.tokens.findIndexByType('rcur', kwPos) + 1
            : kwPos + 2
        if (this.tokens.length <= identPos) return;

        this.tokens[identPos].setType('alias').setClassName('hl-al');
        this.nsStack.append(this.tokens[identPos].lexeme, 'alias')
    }

    private parseStruct(kwPos: number) {
        const nextToken = (kwPos + 1 < this.tokens.length) ? this.tokens[kwPos + 1] : new Token();
        const followedByIdent = nextToken.isTypeEqualTo('identifier');
        if (followedByIdent) this.tokens[kwPos + 1].setType('alias').setClassName('hl-al');

        if (followedByIdent) {
            const nextnextToken = (kwPos + 2 < this.tokens.length) ? this.tokens[kwPos + 2] : new Token();
            if (nextnextToken.isTypeEqualTo('identifier') || nextnextToken.isLexemeEqualTo('*')) this.parseDeclaration(kwPos + 1);
        }
    }

    private parseEnum(kwPos: number) {
        const nextToken = (kwPos + 1 < this.tokens.length) ? this.tokens[kwPos + 1] : new Token();
        const followedByIdent = nextToken.isTypeEqualTo('identifier');
        if (followedByIdent) this.tokens[kwPos + 1].setType('alias').setClassName('hl-al');

        if (followedByIdent) {
            const nextnextToken = (kwPos + 2 < this.tokens.length) ? this.tokens[kwPos + 2] : new Token();
            if (nextnextToken.isTypeEqualTo('identifier') || nextnextToken.isLexemeEqualTo('*')) this.parseDeclaration(kwPos + 1);
        }

        const lcurPos = this.tokens.findIndexByType('lcur', kwPos);
        const isDeclaration = lcurPos !== -1 && lcurPos - kwPos <= 2;
        if (!isDeclaration) return;

        const from = lcurPos + 1;
        const to   = this.tokens.findIndexByType('rcur', kwPos) - 1;
        for (let i = from; i <= to; i++) {
            const token = this.tokens[i];
            if (token.isTypeEqualTo('identifier')) {
                this.tokens[i].setType('enumMember').setClassName('hl-en');
                this.nsStack.append(token.lexeme, 'enumMember');
            }
        }
    }

    private parseDeclaration(varTypePos: number) {
        let i: number;
        for (i = varTypePos + 1; i < this.tokens.length && this.tokens[i].isLexemeEqualTo('*'); i++);
        const isDeclaration = i < this.tokens.length && this.tokens[i].isTypeEqualTo('identifier');

        if (!isDeclaration) return;  // (e.g.) cast operation

        const isFunctionDeclaration = i + 1 < this.tokens.length && this.tokens[i + 1].isLexemeEqualTo('(');
        if (isFunctionDeclaration) {
            this.tokens[i].setType('function').setClassName('hl-f');
            this.nsStack.append(this.tokens[i].lexeme, 'function');
            const semicPos = this.tokens.findIndexByType('semic', i);
            const lcurPos  = this.tokens.findIndexByType('lcur',  i);
            if (lcurPos > 0 && (lcurPos < semicPos || lcurPos < 0)) {
                this.nsStack = this.nsStack.createChildScope();
                this.isStackedByFunc = true;
            }
            const rbraPos = this.tokens.findIndexByLexeme(')', i);
            for (let j = i + 2; j < rbraPos; j++) {
                const token     = this.tokens[j];
                const prevToken = this.tokens[j - 1];
                if (this.nsStack.has(token.lexeme, 'alias') && prevToken.isLexemeEqualTo(['(', ','])) {
                    this.tokens[j].setType('variableType').setClassName('hl-al');
                }
            }
        } else {
            this.parseDeclarationStat(varTypePos);
        }
    }

    private parseDeclarationStat(varTypePos: number) {
        const semicPos = this.tokens.findIndexByType('semic', varTypePos);
        const rbraPos  = this.tokens.findIndexByLexeme(')', varTypePos);  // For function definition

        const from = varTypePos + 1;
        const to   = Math.min(semicPos, rbraPos) - 1;
        for (let i = from; i <= to; i++) {
            const token     = this.tokens[i];
            const prevToken = this.tokens[i - 1];
            if (token.isTypeEqualTo('identifier') && (prevToken.isTypeEqualTo('comma') || prevToken.isLexemeEqualTo('*') || i === from)) {
                this.nsStack.append(token.lexeme, 'variable');
                this.tokens[i].setType('variable').setClassName('hl-v');
            }
        }
    }

    private parseIdentifier(pos: number) {
        const token     = this.tokens[pos];
        const prevToken = (pos > 0)                      ? this.tokens[pos - 1] : new Token();
        const nextToken = (pos + 1 < this.tokens.length) ? this.tokens[pos + 1] : new Token();

        if (this.nsStack.has(token.lexeme, 'macroConstant')) {
            this.tokens[pos].setType('macroConstant').setClassName('hl-mc');
        } else if (this.nsStack.has(token.lexeme, 'enumMember')) {
            this.tokens[pos].setType('enumMember').setClassName('hl-en');
        } else if (prevToken.isTypeEqualTo('memberRef')) {
            this.tokens[pos].setType('structMember').setClassName('hl-v');
        } else if (this.nsStack.has(token.lexeme, 'alias')) {
            this.parseAlias(pos);  // determine if it is variable or alias
        } else if (nextToken.isLexemeEqualTo('(')) {
            this.tokens[pos].setType('function').setClassName('hl-f');
        }
    }

    private parseAlias(aliasPos: number) {
        const prevprevToken = (aliasPos - 1 > 0)                  ? this.tokens[aliasPos - 2] : new Token();
        const prevToken     = (aliasPos > 0)                      ? this.tokens[aliasPos - 1] : new Token();
        const nextToken     = (aliasPos + 1 < this.tokens.length) ? this.tokens[aliasPos + 1] : new Token();

        if ((!prevToken.isTypeEqualTo('other') || aliasPos === 0) &&  // NOT operator, left-bracket, etc...
            (nextToken.isTypeEqualTo('identifier') || nextToken.isLexemeEqualTo('*'))) {  // variable declaration
            this.tokens[aliasPos].setType('alias').setClassName('hl-al');
            this.parseDeclaration(aliasPos);
        } else if (prevprevToken.isLexemeEqualTo('sizeof') && this.nsStack.getTypeByName(this.tokens[aliasPos].lexeme) === 'alias') {  // operand of sizeof()
            this.tokens[aliasPos].setType('alias').setClassName('hl-al');
        } else if (prevToken.isLexemeEqualTo('(')) {  // cast operation
            let i: number;
            for (i = aliasPos + 1; i < this.tokens.length && this.tokens[i].isLexemeEqualTo('*'); i++);
            if (i + 1 >= this.tokens.length) return;
            if (this.tokens[i].isLexemeEqualTo(')') && this.tokens[i + 1].isTypeEqualTo(['identifier'])) 
                this.tokens[aliasPos].setType('alias').setClassName('hl-al');
        } 
    }

    private stackNamespace() {
        if (this.isStackedByFunc) {
            this.isStackedByFunc = false;
            return;
        }
        this.nsStack = this.nsStack.createChildScope();
    }

    private popNamespace() {
        this.nsStack = this.nsStack.escapeScope();
    }
}
\end{lstlisting}

実装のポイントは，同一名称の\verb|typedef|名と変数を名前空間の管理により適切にハイライトしている点である．
例えば，キャスト演算や変数宣言，\verb|sizeof()|の際にトークンの並びや名前空間\verb|nsStack|を元に属性を振り分けている．

また，ヘッダファイルに登録されているマクロ定数や型エイリアスは\verb|constructor|で文字列を元にグローバルスコープに登録するようにしている．

実装において苦労した点は，型エイリアスによるポインタ変数の宣言である．
トークン解析の際には，トークンの並びが\verb|"identifier * identifier ..."|となるため，同一名称の変数が存在する場合に算術式との区別が付かない．
そこで，直前のトークンが\verb|')'|や\verb|'='|等の演算記号でない場合は変数宣言であると解釈したのだが，無理矢理な実装となってしまった(201行目)．

関数定義の場合は，\verb|{|によるブロック形成が行われる前に変数宣言が行われる可能性がある(仮引数宣言)．
そこで，関数定義の開始時にはその時点でスコープを形成し，\verb|{|によるブロック形成をスキップする方針とした．

次に，改善点を二つ述べる．
一つ目は，\verb|for|文初期化式での変数宣言への対応である．
\verb|for|文終了時での適切なスコープの脱退が課題であり，現在は実装ができていない．
これは，Cにおいては現状のままでも特に問題なくハイライトを施すことができる．
しかし，JS等の言語においては適切なスコープの形成・脱退を行わなければ，同一名称の場合に定数か変数を判断できないため，改善が必要である．
二つ目は，リファクタリングである．現コードでは，エイリアスによる変数宣言に関するハイライト等，見通しの悪い実装が多々ある．
そこで，\verb|Token|のタグの活用等を含めて実装方針を再検討することも必要であろう．

今後の展望としては，別ファイルで定義した定数等もハイライトできるよう，独自の形式言語で名前空間に登録する機能が考えられる．

最後に，\figref{img:c-sample}のCプログラムを与えた結果得られる\verb|nsStack|を\figref{img:c-json}に示す．

\begin{figure}[ht]
\centering
\begin{minipage}[b]{0.49\columnwidth}
  \centering
  \includegraphics[width=0.9\columnwidth]{c-sample.png}
  \caption{{\tt ハイライトの例}}
  \label{img:c-sample}
\end{minipage}
\begin{minipage}[b]{0.49\columnwidth}
  \centering
  \includegraphics[width=0.9\columnwidth]{c-json.png}
  \caption{{\tt 得られる名前空間}}
  \label{img:c-json}
\end{minipage}
\end{figure}

%--------------------------------------------------------------------%
\section{おわりに}

以上の流れでWebシンタックスハイライタを作成したが実行環境の構築から作成方針の検討・実装に至るまで，非常に多くの学びがあった．
しかし，更なるコードの改善やリファクタリング等，課題も多く残っている．
今後はこれらの課題を改善しつつ，対応するソースコードを増やす等のアップデートを行っていきたい．

%--------------------------------------------------------------------%
\begin{thebibliography}{99}
  \bibitem{www:1}  Node.jsとはなにか？， \spverb!https://qiita.com/non_cal/items/a8fee0b7ad96e67713eb!，2024/12/5
  \bibitem{www:2}  nodejsとは，\spverb!https://kinsta.com/jp/knowledgebase/what-is-node-js/!，2024/12/5.
  \bibitem{www:3}  npmとは，\spverb!https://kinsta.com/jp/knowledgebase/what-is-npm/!，2024/12/5.
  \bibitem{www:4}  package.jsonの中身を理解する，\\ \spverb!https://qiita.com/dondoko-susumu/items/cf252bd6494412ed7847!，2024/12/5.
  \bibitem{www:5}  最新版で学ぶwebpack 5入門，\spverb!https://ics.media/entry/12140/!，2024/12/5.
  \bibitem{www:7}  npm install の --save-dev って何？，\\ \spverb!https://qiita.com/kohecchi/items/092fcbc490a249a2d05c!，2024/12/6.
  \bibitem{www:8}  TypeScriptチュートリアル -環境構築編-，\\ \spverb!https://qiita.com/ochiochi/items/efdaa0ae7d8c972c8103!，2024/12/6.
  \bibitem{www:9}  webpackの苦手意識を無くす，\spverb!https://zenn.dev/msy/articles/c1f00c55e88358!，2024/12/8.
  \bibitem{www:10} CSSで宇宙空間を表現する。，\spverb!https://qiita.com/junya/items/a2f8984841dc0d559a68!，2024/12/9.
  \bibitem{www:11} 【Font Awesome】バージョン6で変わったCSS擬似要素の設定でアイコン表示する時の備忘録いろいろ，\\ \spverb!https://www.appleach.co.jp/note/webdesigner/6960/!，2024/12/13.
  \bibitem{www:12} Webpack5でFontAwesome-freeを利用する，\\ \spverb!https://zenn.dev/manappe/articles/da22d23f73de3b!，2024/12/13.
  \bibitem{www:13} Documentation， \spverb!https://sass-lang.com/documentation/!，2024/12/18.
  \bibitem{www:14} プロトタイプ汚染とは，\\ \spverb!https://www.sompocybersecurity.com/column/glossary/prototype-pollution!，2024/12/19.
  \bibitem{www:15} 「Typescript」でprototypeの沼にハマったので、色々調べてみた。，\\ \spverb!https://note.alhinc.jp/n/n2ee7f772e020!，2024/12/19.
  \bibitem{www:16} ReactにTypeScriptで拡張メソッドを作る，\\ \spverb!https://qiita.com/s-ueno/items/90030bab006c79173dc5!，2024/12/19.
  \bibitem{www:17} 名前空間，\\ \spverb!https://learn.microsoft.com/ja-jp/cpp/c-language/name-spaces?view=msvc-170!，2025/1/26.
  \bibitem{www:18} JSON CRACK，\spverb!https://jsoncrack.com/editor!，2024/1/26.

\end{thebibliography}
%--------------------------------------------------------------------%
\end{document}